from __future__ import absolute_import
from __future__ import print_function

import pandas as pd
import numpy as np
import copy
import tempfile
from tqdm import tqdm
import itertools
import os
from kipoi.components import ArraySpecialType, MetadataType
import six

def _vcf_to_regions(vcf_fpath, seq_length, id_delim=":"):
    # VCF files are 1-based, so the return value here is 1-based
    colnames = ["chrom", "pos", "id", "ref", "alt"]
    vcf = pd.read_csv(vcf_fpath, sep="\t", comment='#', header=None, usecols=range(len(colnames)))
    vcf.columns = colnames
    vcf["chrom"] = "chr" + vcf["chrom"].str.lstrip("chr")
    seq_length_half = int(seq_length / 2)
    l_offset = seq_length_half
    r_offset = seq_length_half - 1 + seq_length % 2
    ids = vcf["chrom"] + id_delim + vcf["pos"].astype(str) + id_delim + vcf["ref"] + id_delim + vcf["alt"]
    regions = pd.DataFrame({"line_id": ids, "chrom": vcf["chrom"].astype(np.str),
                            "start": vcf["pos"] - l_offset, "end": vcf["pos"] + r_offset})
    regions["ref"] = vcf["ref"]
    regions["alt"] = vcf["alt"]
    regions["varpos"] = vcf["pos"]
    return regions


def _bed3(regions, fpath):
    regions_0based = copy.deepcopy(regions)
    regions_0based["start"] = regions_0based["start"] - 1
    regions_0based[["chrom", "start", "end"]].to_csv(fpath, sep="\t", header=False, index=False)


def _generate_seq_sets(model_input, annotated_regions, dataloader):
    # annotated_regions comes from the vcf file
    # This function has to convert the DNA regions in the model input according to ref, alt, fwd, rc and
    # return a dictionary of which the keys are compliant with evaluation_function arguments
    #
    # TODO: Implement checking for preprocessors that output fwd and rc sequences themselves
    # TODO: Implement support for models that have fwd + rc sequence input at once
    #
    dna_slots = []
    ranges_slots = []

    # check for inputs with special_type ArraySpecialType.DNASeq
    for k in dataloader.schema.inputs:
        if dataloader.schema.inputs[k].special_type == ArraySpecialType.DNASeq:
            dna_slots.append(k)

    # check for metadata with type MetadataType.RANGES
    for k, v in six.iteritems(dataloader.schema.metadata):
        if v.type == MetadataType.RANGES:
            ranges_slots.append(k)
    #
    if len(ranges_slots) == 0:
        raise ValueError("No metadata with type: Ranges found")
    #
    # there will at max be one element in the ranges_slots object
    # extract the metadata output
    # TODO - use associated_metadata to check
    ranges_input_obj = model_input['metadata'][ranges_slots[0]]
    #
    # annotated_regions are 1-based coordinates!
    annotated_regions = copy.deepcopy(annotated_regions)
    #
    annotated_regions["region"] = annotated_regions["chrom"] + ":" + annotated_regions["start"].astype(str) + "-" + annotated_regions["end"].astype(str)
    annotated_regions["varpos_rel"] = annotated_regions["varpos"] - annotated_regions["start"]
    #
    # Object that holds annotation of the sequences
    preproc_out_ranges = {}
    preproc_out_ranges["pp_line"] = list(range(len(ranges_input_obj["chr"])))
    preproc_out_ranges["region"] = ["%s:%d-%d" % (ranges_input_obj["chr"][i],
                                                  ranges_input_obj["start"][i] + 1,
                                                  ranges_input_obj["end"][i])
                                    for i in range(len(ranges_input_obj["chr"]))]
    #
    # Get the strand of the output sequences from the preprocessor
    if "strand" in ranges_input_obj:
        preproc_out_ranges["strand"] = ranges_input_obj["strand"]
    else:
        preproc_out_ranges["strand"] = ["*"] * len(ranges_input_obj["chrom"])
    #
    preproc_out_ranges = pd.DataFrame(preproc_out_ranges)
    #
    # Annotate the sequences generated by the preprocessor
    preproc_conv = preproc_out_ranges.merge(annotated_regions, on="region")
    #
    # Generate the object for model prediction: Copy object if it will have to be modified
    input_set = {}
    seq_set_labels = ["fwd_ref", "fwd_alt", "rc_ref", "rc_alt"]
    for k in seq_set_labels:
        input_set[k] = {}
        for k2 in model_input['inputs']:
            if k2 in dna_slots:
                assert model_input['inputs'][k2].shape[1] == (annotated_regions["end"] - annotated_regions["start"] + 1).values[0]
                input_set[k][k2] = copy.deepcopy(model_input['inputs'][k2])
            else:
                input_set[k][k2] = model_input['inputs'][k2]
    #
    # Actually modify sequences according to annotation
    for s_dir, allele in itertools.product(["fwd", "rc"], ["ref", "alt"]):
        k = "%s_%s" % (s_dir, allele)
        for k2 in dna_slots:
            if k2 in input_set[k]:
                # Modify bases according to allele
                modify_bases(input_set[k][k2], preproc_conv["pp_line"].values, preproc_conv["varpos_rel"].values,
                             preproc_conv[allele].values, preproc_conv["strand"].values == "-")
                # subset to the lines that have been identified
                if input_set[k][k2].shape[0] != preproc_conv.shape[0]:
                    input_set[k][k2] = input_set[k][k2][preproc_conv["pp_line"].values, ...]
                # generate reverse complement if needed
                if s_dir == "rc":
                    input_set[k][k2] = input_set[k][k2][:, ::-1, ::-1]
    #
    # Reformat so that effect prediction function will get its required inputs
    pred_set = {"ref": input_set["fwd_ref"], "ref_rc": input_set["rc_ref"], "alt": input_set["fwd_alt"], "alt_rc": input_set["rc_alt"]}
    pred_set["mutation_positions"] = preproc_conv["varpos_rel"].values
    return pred_set


def modify_bases(seq_obj, lines, pos, base, is_rc):
    # Check whether this code does what it should...
    alphabet = np.array(['A', "C", "G", "T"])
    base_sel = np.where(alphabet[None, :] == base[:, None])
    base_sel_idx = base_sel[1][np.argsort(base_sel[0])]
    if is_rc.sum() != 0:
        pos[is_rc] = seq_obj.shape[1] - pos[is_rc] - 1
        base_sel_idx[is_rc] = alphabet.shape[0] - base_sel_idx[is_rc] - 1
    # Reset the base which was there from the preprocessor
    seq_obj[lines, pos, :] = 0
    # Set the allele
    seq_obj[lines, pos, base_sel_idx] = 1


def predict_variants(model_handle,
                     vcf_fpath,
                     seq_length,
                     evaluation_function,
                     exec_files_path,
                     dataloader_function,
                     batch_size,
                     model_out_annotation,
                     debug=False,
                     evaluation_function_kwargs=None):
    # if 'intervals_file' not in model_handle.preproc.get_avail_arguments():
    #    raise Exception("Preprocessor does not support DNA regions as input.")
    # seq_pp_outputs = model_handle.preproc.get_output_label_by_type("dna")
    # if len(seq_pp_outputs)==0:
    #    raise Exception("Preprocessor does not generate DNA sequences.")
    #
    regions = _vcf_to_regions(vcf_fpath, seq_length)
    temp_bed3_file = tempfile.mktemp()  # file path of the temp file
    _bed3(regions, temp_bed3_file)
    exec_files_path['intervals_file'] = temp_bed3_file
    #
    res = []
    #
    dataloader_function(**exec_files_path)
    #
    it = dataloader_function(**exec_files_path).batch_iter(batch_size=batch_size)
    # test that all predictions go through
    for i, batch in enumerate(tqdm(it)):
        eval_kwargs = _generate_seq_sets(batch, regions, dataloader_function)
        if evaluation_function_kwargs is not None:
            assert isinstance(evaluation_function_kwargs, dict)
            for k in evaluation_function_kwargs:
                eval_kwargs[k] = evaluation_function_kwargs[k]
        eval_kwargs["out_annotation_all_outputs"] = model_out_annotation
        if debug:
            for k in ["ref", "ref_rc", "alt", "alt_rc"]:
                print(k)
                print(model_handle.predict_on_batch(eval_kwargs[k]))
                print("".join(["-"] * 80))
        res.append(evaluation_function(model_handle, **eval_kwargs))
    #
    try:
        os.unlink(temp_bed3_file)
    except:
        pass
    return res

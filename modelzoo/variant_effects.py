from __future__ import absolute_import
from __future__ import print_function

import pandas as pd
import numpy as np
import copy
import tempfile
from tqdm import tqdm
import itertools
import os

from torch.utils.data import DataLoader


def _vcf_to_regions(vcf_fpath, seq_length, id_delim=":"):
    # VCF files are 1-based, so the return value here is 1-based
    colnames = ["chrom", "pos", "id", "ref", "alt"]
    vcf = pd.read_csv(vcf_fpath, sep="\t", comment='#', header=None, usecols=range(len(colnames)))
    vcf.columns = colnames
    vcf["chrom"] = "chr" + vcf["chrom"].str.lstrip("chr")
    seq_length_half = int(seq_length/2)
    l_offset = seq_length_half
    r_offset = seq_length_half - 1 + seq_length % 2
    ids = vcf["chrom"] + id_delim + vcf["pos"].astype(str) + id_delim + vcf["ref"] + id_delim + vcf["alt"]
    regions = pd.DataFrame({"line_id": ids, "chrom": vcf["chrom"].astype(np.str),
                            "start": vcf["pos"] - l_offset, "end": vcf["pos"] + r_offset})
    regions["ref"] = vcf["ref"]
    regions["alt"] = vcf["alt"]
    regions["varpos"] = vcf["pos"]
    return regions

def _bed3(regions, fpath):
    regions_0based = copy.deepcopy(regions)
    regions_0based["start"] = regions_0based["start"] - 1
    regions_0based[["chrom", "start", "end"]].to_csv(fpath, sep="\t", header=False, index=False)

def _generate_seq_sets(model_input, annotated_regions, extractor_function):
    # annotated_regions comes from the vcf file
    # This function has to convert the DNA regions in the model input according to ref, alt, fwd, rc and
    # return a dictionary of which the keys are compliant with evaluation_function arguments
    #
    # TODO: Implement checking for preprocessors that output fwd and rc sequences themselves
    # TODO: Implement support for models that have fwd + rc sequence input at once
    preproc_spec = extractor_function.definition
    #
    dna_slots = []
    ranges_slots = []
    for k in preproc_spec['output']['inputs']:
        if "type" in preproc_spec['output']['inputs'][k]:
            if preproc_spec['output']['inputs'][k]['type'] == "DNA":
                dna_slots.append(k)
    #
    if 'ranges' in preproc_spec['output']['metadata']:
        if {'chr', 'start', 'end'}.issubset(set(preproc_spec['output']['metadata']['ranges'].keys())):
            ranges_slots.append('ranges')
    #
    if len(ranges_slots) == 0:
        raise Exception("")
    #
    # there will at max be one element in the ranges_slots object
    ranges_input_obj = model_input['metadata'][ranges_slots[0]]
    #
    # annotated_regions are 1-based coordinates!
    annotated_regions = copy.deepcopy(annotated_regions)
    #
    annotated_regions["region"] = annotated_regions["chrom"] + ":" + annotated_regions["start"].astype(str) + "-" + annotated_regions["end"].astype(str)
    annotated_regions["varpos_rel"] = annotated_regions["varpos"] - annotated_regions["start"]
    #
    # Object that holds annotation of the sequences
    preproc_out_ranges = {}
    preproc_out_ranges["pp_line"] = list(range(len(ranges_input_obj["chr"])))
    preproc_out_ranges["region"] = ["%s:%d-%d" % (ranges_input_obj["chr"][i], ranges_input_obj["start"][i]+1,ranges_input_obj["end"][i]) for i in range(len(ranges_input_obj["chr"]))]
    #
    # Get the strand of the output sequences from the preprocessor
    if "strand" in ranges_input_obj:
        preproc_out_ranges["strand"] = ranges_input_obj["strand"]
    else:
        preproc_out_ranges["strand"] = ["*"]*len(ranges_input_obj["chrom"])
    #
    preproc_out_ranges = pd.DataFrame(preproc_out_ranges)
    #
    # Annotate the sequences generated by the preprocessor
    preproc_conv = preproc_out_ranges.merge(annotated_regions, on = "region")
    #
    # Generate the object for model prediction: Copy object if it will have to be modified
    input_set = {}
    seq_set_labels = ["fwd_ref", "fwd_alt", "rc_ref", "rc_alt"]
    for k in seq_set_labels:
        input_set[k] = {}
        for k2 in model_input['inputs']:
            if k2 in dna_slots:
                assert model_input['inputs'][k2].shape[1] == (annotated_regions["end"] - annotated_regions["start"]+1).values[0]
                input_set[k][k2] = copy.deepcopy(model_input['inputs'][k2])
            else:
                input_set[k][k2] = model_input['inputs'][k2]
    #
    # Actually modify sequences according to annotation
    for s_dir, allele in itertools.product(["fwd", "rc"], ["ref", "alt"]):
        k = "%s_%s"%(s_dir, allele)
        for k2 in dna_slots:
            if k2 in input_set[k]:
                # Modify bases according to allele
                modify_bases(input_set[k][k2], preproc_conv["pp_line"].values, preproc_conv["varpos_rel"].values,
                             preproc_conv[allele].values, preproc_conv["strand"].values=="-")
                # subset to the lines that have been identified
                if input_set[k][k2].shape[0] != preproc_conv.shape[0]:
                    input_set[k][k2] = input_set[k][k2][preproc_conv["pp_line"].values, ...]
                # generate reverse complement if needed
                if s_dir == "rc":
                    input_set[k][k2] = input_set[k][k2][:,::-1,::-1]
    #
    # Reformat so that effect prediction function will get its required inputs
    pred_set = {"ref":input_set["fwd_ref"], "ref_rc":input_set["rc_ref"], "alt":input_set["fwd_alt"], "alt_rc":input_set["rc_alt"]}
    pred_set["mutation_positions"] = preproc_conv["varpos_rel"].values
    return pred_set

def modify_bases(seq_obj, lines, pos, base, is_rc):
    # Check whether this code does what it should...
    alphabet = np.array(['A', "C", "G", "T"])
    base_sel = np.where(alphabet[None,:] == base[:,None])
    base_sel_idx = base_sel[1][np.argsort(base_sel[0])]
    if is_rc.sum() != 0:
        pos[is_rc] =seq_obj.shape[1]-pos[is_rc]-1
        base_sel_idx[is_rc] = alphabet.shape[0] - base_sel_idx[is_rc] - 1
    # Reset the base which was there from the preprocessor
    seq_obj[lines, pos, :] = 0
    # Set the allele
    seq_obj[lines, pos, base_sel_idx] = 1


def predict_variants(model_handle, vcf_fpath, seq_length, evaluation_function, exec_files_path, extractor_function, batch_size, numpy_collate, model_out_annotation, debug=False, evaluation_function_kwargs = None):
    #if 'intervals_file' not in model_handle.preproc.get_avail_arguments():
    #    raise Exception("Preprocessor does not support DNA regions as input.")
    #seq_pp_outputs = model_handle.preproc.get_output_label_by_type("dna")
    #if len(seq_pp_outputs)==0:
    #    raise Exception("Preprocessor does not generate DNA sequences.")
    #
    regions = _vcf_to_regions(vcf_fpath, seq_length)
    temp_bed3_file = tempfile.mktemp() # file path of the temp file
    _bed3(regions, temp_bed3_file)
    exec_files_path['intervals_file'] = temp_bed3_file
    #
    res = []
    #
    extractor_function(**exec_files_path)
    #
    it = DataLoader(extractor_function(**exec_files_path), batch_size=batch_size, collate_fn=numpy_collate)
    # test that all predictions go through
    for i, batch in enumerate(tqdm(it)):
        eval_kwargs = _generate_seq_sets(batch, regions, extractor_function)
        if evaluation_function_kwargs is not None:
            assert isinstance(evaluation_function_kwargs, dict)
            for k in evaluation_function_kwargs:
                eval_kwargs[k] = evaluation_function_kwargs[k]
        eval_kwargs["out_annotation_all_outputs"] = model_out_annotation
        if debug:
            for k in ["ref", "ref_rc", "alt", "alt_rc"]:
                print (k)
                print (model_handle.predict_on_batch(eval_kwargs[k]))
                print ("".join(["-"]*80))
        res.append(evaluation_function(model_handle, **eval_kwargs))
    #
    try:
        os.unlink(temp_bed3_file)
    except:
        pass
    return res
